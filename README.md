# 객체지향 강의.
#### by. 조용호

----
## 객체지향

### 설계 시 행동을 우선으로 설계하라.
- 나이를 물었을 때 적합한게 뭐야? = 상태, 행동을 같은 단위로 가짐.

#### 객체지향 설계 원칙
- 객체 = 작을수록 좋다.
- 클래스가 많아지더라도 객체는 작을수록 좋음. = 단일책임원칙.
- 클래스가 커지면 단일책임원칙이 깨진다.

- 할 수 있는 건 하고 하기 애매한 건 미루기.

객체가 다른객체한테 메시지를 줌. (메시지를 콜)
메시지로 응답하기 좋은 객체를 찾는다.

문맥을 만들고 적합한 행동을 하나 씩 뽑아낸다.
절차적으로 구현한 후 리펙토링 -> 가장 효율적인 객체지향 구현법.

객체지향의 책임과 단일책임원칙의 책임은 다르다.
단일책임원칙 = 이 클래스가 변경되어야 하는 이유는 하나여야 한다.
설계 = 모두 변경과 연관이 되어 있다. => 디자인패턴 싱글톤? 이상한거다.
변경하는 부분들의 시점이 다르다 == SRP위반.

당장 해당객체에서 하기 애매한것같다. 미뤄버리기.
클래스와 객체는 다르다.

행동중심으로 설계 = 책임중심설계

절차지향 if 문이 나옴. 객체지향 = 너가 해줘. -> 알아서 해당객체가 해주기에 캡슐화가 가능.

결합도가 높다. = 변경에 따라 같이 변경이 자주 됨.
변경 시 특정부분”만” 변경됨 = 응집도가 높다.

각자 다른 구현을 원한다면 인터페이스
행동만 공유하고 싶다면 abstact

if가 없다 = 다형성
변경 시 해당부분만 고치면 된다.
다형성 장점 -> 변경을 캡슐화하기에. => 설계복잡도를 높이겠다.

절차적인 코드가 쉬워보이는 이유 => 직관적이기에.
절차코드 단점. 코드 수정이 너무 어렵다.

객체지향의 장점 = 명사. 코드수정을 원할 시 해당 이름의 클래스를 찾아가면 된다.
객체지향의 단점 = 코드를 읽기 어렵다.
Self call = 자신에게 메시지를 보냄. -> Static

객체지향 == 다 다형성.
도메인 기반으로 코드를 작성.

Domain Model pattern
도메인 = 개념적으로 정리한게 있다.
필요한것만 가져와서 모아둔 것 = 모델
도메인 모델 패턴으로 만들어줘 -> 객체지향으로 만들어줘

절차지향은 나쁜게 아니다.
절차지향이 필요한 곳에서는 절차지향으로 써야한다.
프로그램의 요구사항.
오늘 완성해야 하는 기능을 구현하는 코드
내일 쉽게 변경할 수 있는 코드여야 한다. -> 단순한 코드여야 한다. -> 내일 쉽게 변경가능할 수 있다.
이걸 어떻게 변경할까? 요구사항에 따라 변경이 유연해야 한다.

실무 -> 말도 안되는걸 요구할 때도 있음.
변화에 대비해 미리 준비해두자.

내 코드 = 다른 사람과 커뮤니케이션 == 글 쓰는 것과 같아야 한다.

배포 -> 위기의 순간.
잘못짜여진 코드. A를 수정했는데 B에서 버그가 발생.
기존 코드 수정하기 -> 개발자들이 가장 어려워 하는것. -> 버그의 잠재적인 가능성이 있음.

실제 해당 로직을 복사하여 붙여놓고 작업하는 경우가 매우 많음.

실무코드에서 일부분 코드르 봤을때 “이게 뭐지?”가 많음.
그 흐름을 파악해야 해당 코드 파악 가능.

미리 짜놓은 코드의 실행흐름 리펙토링 가능성
절차 = X, 객체 = O

설계 = 무조건 변경하게 됨.
컴포지트 디자인패턴.
-> 디자인패턴 중요성 : 무언가 변경될 때 어떤걸 캡슐화 하고 싶냐?

(메시지로 객체를 캡슐화) 
기존코드를 수정치 않고 추가만 함. -> 기존 코드를 수정했을 때의 버그가능성이 없음.

명사를 최대한 활용하자!! 
캡슐화 = OCP
시스템 확장에는 열려있음. 수정에는 닫혀있음.
메시지와 메서드를 구분해서 객체와 객체의 관계로 푼다.
비지니스 로직은 되게 빨리 바뀜

요구사항이 어떻게 변경될 지 모른다면???
초반은 심플 ->->—>-> 갈수록 복잡.
초반에는 심플하게 개발하는게 좋음.
변경은 항상 이상한게 들어옴.
리펙토링은 안고 살아야 한다. 필수! 단위테스트도 필수! 리펙토링 열심히하자!!
처음부터 완벽한 코드는 불가. -> 요구사항이 어떻게 들어오고 바뀔 수 없기에.

인터페이스도 찢어야 된다.
어떤 객체가 뭘 했으면 좋겠어. 이걸 테스트로 설계하며 구현해보자 = TDD
설계, 구현 후 곧장 테스트.
